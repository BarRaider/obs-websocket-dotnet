using Newtonsoft.Json.Linq;
using System;

namespace OBSWebsocketDotNet.Types
{
    /// <summary>
    /// Describes an Output in OBS.
    /// </summary>
    public class OBSOutputInfo
    {
        /// <summary>
        /// Creates a new <see cref="OBSOutputInfo"/> from a JSON object.
        /// If the response is recognized as a Stream or File output, a <see cref="StreamOutputInfo"/> or <see cref="FileOutputInfo"/> will be returned with the Output settings.
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        public static OBSOutputInfo CreateOutput(JObject response)
        {
            string outputName = response["name"]?.Value<string>().ToLower() ?? throw new ErrorResponseException("Output response did not contain 'name' for the Output", response);
            if (outputName.Length == 0)
            {
                OBSLogger.Warning($"Invalid output name from response: {response.ToString(Newtonsoft.Json.Formatting.None)}");
                // TODO: Should this throw an exception or return null?
            }
            else if (outputName.Contains("stream"))
            {
                return new StreamOutputInfo(response);
            }
            else if (outputName.Contains("file"))
            {
                return new FileOutputInfo(response);
            }
            else if (outputName.Contains("replay"))
            {
                return new ReplayOutputInfo(response);
            }
            else
            {
                OBSLogger.Warning($"Received an unrecognized output name: {outputName}");
            }
            return new OBSOutputInfo(response);
        }

        /// <summary>
        /// Constructs a new generic <see cref="OBSOutputInfo"/> from a response.
        /// </summary>
        /// <param name="response"></param>
        protected OBSOutputInfo(JObject response)
        {
            Name = response["name"]?.Value<string>() ?? throw new ErrorResponseException("Output response did not contain 'name'", response);
            Type = response["type"]?.Value<string>() ?? throw new ErrorResponseException("Output response did not contain 'type'", response);
            Width = response["width"]?.Value<int>() ?? -1;
            Height = response["height"]?.Value<int>() ?? -1;
            Flags = (OutputFlags)(response["flags"]?["rawValue"]?.Value<int>() ?? 0);
            Active = response["active"]?.Value<bool>() ?? false;
            Reconnecting = response["reconnecting"]?.Value<bool>() ?? false;
            Congestion = response["congestion"]?.Value<double>() ?? 0;
            TotalFrames = response["totalFrames"]?.Value<int>() ?? 0;
            DroppedFrames = response["droppedFrames"]?.Value<int>() ?? 0;
            TotalBytes = response["totalBytes"]?.Value<int>() ?? 0;
        }
        /// <summary>
        /// Name of the output.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Type of the output.
        /// </summary>
        public readonly string Type;
        /// <summary>
        /// Width of the output video.
        /// </summary>
        public readonly int Width;
        /// <summary>
        /// Height of the output video.
        /// </summary>
        public readonly int Height;
        /// <summary>
        /// <see cref="OutputFlags"/> describing the output.
        /// </summary>
        public readonly OutputFlags Flags;
        /// <summary>
        /// True if the output is active.
        /// </summary>
        public readonly bool Active;
        /// <summary>
        /// True if the output is reconnecting.
        /// </summary>
        public readonly bool Reconnecting;
        /// <summary>
        /// Percent of dropped frames.
        /// </summary>
        public readonly double Congestion;
        /// <summary>
        /// Total frames outputted by the output.
        /// </summary>
        public readonly int TotalFrames;
        /// <summary>
        /// Number of frames dropped by the output.
        /// </summary>
        public readonly int DroppedFrames;
        /// <summary>
        /// Total bytes generated by the output.
        /// </summary>
        public readonly int TotalBytes;
    }

    /// <summary>
    /// An <see cref="OBSOutputInfo"/> with stream specific properties.
    /// </summary>
    public class StreamOutputInfo : OBSOutputInfo
    {
        /// <summary>
        /// Stream output settings.
        /// </summary>
        public readonly StreamOutputSettings Settings;

        /// <summary>
        /// Creates a new <see cref="StreamOutputInfo"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="response"></param>
        public StreamOutputInfo(JObject response)
            : base(response)
        {
            if (response["settings"] is JObject settings)
                Settings = new StreamOutputSettings(settings);
        }
    }

    /// <summary>
    /// An <see cref="OBSOutputInfo"/> with file specific properties.
    /// </summary>
    public class FileOutputInfo : OBSOutputInfo
    {
        /// <summary>
        /// File output settings.
        /// </summary>
        public readonly FileOutputSettings Settings;

        /// <summary>
        /// Creates a new <see cref="FileOutputInfo"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="response"></param>
        public FileOutputInfo(JObject response)
            : base(response)
        {

            if (response["settings"] is JObject settings)
                Settings = new FileOutputSettings(settings);
        }
    }

    /// <summary>
    /// An <see cref="OBSOutputInfo"/> with replay specific properties.
    /// </summary>
    public class ReplayOutputInfo : OBSOutputInfo
    {
        /// <summary>
        /// File output settings.
        /// </summary>
        public readonly ReplayOutputSettings Settings;

        /// <summary>
        /// Creates a new <see cref="ReplayOutput"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="response"></param>
        public ReplayOutputInfo(JObject response)
            : base(response)
        {
            if (response["settings"] is JObject settings)
                Settings = new ReplayOutputSettings(settings);
        }
    }

#pragma warning disable CA1815 // Override equals and operator equals on value types
    /// <summary>
    /// Settings specific to file outputs.
    /// </summary>
    public struct FileOutputSettings
    {
        /// <summary>
        /// Creates a new <see cref="FileOutputSettings"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject"></param>
        public FileOutputSettings(JObject jObject)
        {
            MuxerSettings = jObject["muxer_settings"]?.Value<string>();
            Path = jObject["path"]?.Value<string>();
        }
        /// <summary>
        /// Muxer settings
        /// </summary>
        public readonly string? MuxerSettings;
        /// <summary>
        /// If recording, contains the current file path. If not recording, contains the previous recording's path or null if a recording hasn't been started.
        /// </summary>
        public readonly string? Path;
    }

    /// <summary>
    /// Settings specific to stream outputs.
    /// </summary>
    public struct StreamOutputSettings
    {
        /// <summary>
        /// Creates a new <see cref="StreamOutputSettings"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject"></param>
        public StreamOutputSettings(JObject jObject)
        {
            BindIP = jObject["bind_ip"]?.Value<string>();
            DynamicBitrate = jObject["dyn_bitrate"]?.Value<bool>() ?? false;
            LowLatencyMode = jObject["low_latency_mode_enabled"]?.Value<bool>() ?? false;
            NewSocketLoopEnabled = jObject["new_socket_loop_enabled"]?.Value<bool>() ?? false;
        }
        /// <summary>
        /// IP the OBS connection is bound to on the local PC. Usually 'default'.
        /// </summary>
        public readonly string? BindIP;
        /// <summary>
        /// True if DynamicBitrate is enabled in OBS.
        /// </summary>
        public readonly bool DynamicBitrate;
        /// <summary>
        /// True if low latency mode is enabled for the stream.
        /// </summary>
        public readonly bool LowLatencyMode;
        /// <summary>
        /// True if new socket loop is enabled in OBS (whatever that is).
        /// </summary>
        public readonly bool NewSocketLoopEnabled;
    }

    /// <summary>
    /// Settings specific to replay outputs.
    /// </summary>
    public struct ReplayOutputSettings
    {
        /// <summary>
        /// Creates a new <see cref="ReplayOutputSettings"/> from a <see cref="JObject"/>.
        /// </summary>
        /// <param name="jObject"></param>
        public ReplayOutputSettings(JObject jObject)
        {
            AllowSpaces = jObject["allow_spaces"]?.Value<bool>() ?? false;
            Directory = jObject["directory"]?.Value<string>();
            Extension = jObject["extension"]?.Value<string>();
            FileFormat = jObject["format"]?.Value<string>();
            MaxSizeMB = jObject["max_size_mb"]?.Value<int>() ?? 0;
            MaxTimeSecond = jObject["max_time_sec"]?.Value<int>() ?? 0;
            MuxerSettings = jObject["muxer_settings"]?.Value<string>();
            Path = jObject["path"]?.Value<string>();
        }

        /// <summary>
        /// True if spaces are allowed in the file name?
        /// </summary>
        public readonly bool AllowSpaces;
        /// <summary>
        /// Directory replays will be saved to.
        /// </summary>
        public readonly string? Directory;
        /// <summary>
        /// Replay file extension.
        /// </summary>
        public readonly string? Extension;
        /// <summary>
        /// Filename format for saved replays.
        /// </summary>
        public readonly string? FileFormat;
        /// <summary>
        /// Maximum replay file size.
        /// </summary>
        public readonly int MaxSizeMB;
        /// <summary>
        /// Maximum replay length (seconds).
        /// </summary>
        public readonly int MaxTimeSecond;
        /// <summary>
        /// Muxer settings for replays.
        /// </summary>
        public readonly string? MuxerSettings;
        /// <summary>
        /// Seems to be the same as <see cref="Directory"/> right now.
        /// </summary>
        public readonly string? Path;
    }
#pragma warning restore CA1815 // Override equals and operator equals on value types

    /// <summary>
    /// Flags describing the output.
    /// </summary>
    [Flags]
    public enum OutputFlags
    {
        /// <summary>
        /// None.
        /// </summary>
        None = 0,
        /// <summary>
        /// Output has video.
        /// </summary>
        Video = 1 << 0,
        /// <summary>
        /// Output has audio.
        /// </summary>
        Audio = 1 << 1,
        /// <summary>
        /// Output has video and audio.
        /// </summary>
        AV = Video | Audio,
        /// <summary>
        /// Output is encoded.
        /// </summary>
        Encoded = 1 << 2,
        /// <summary>
        /// Output uses a service.
        /// </summary>
        UsesService = 1 << 3,
        /// <summary>
        /// Output has multiple tracks.
        /// </summary>
        Multitrack = 1 << 4,
        /// <summary>
        /// Output can be paused.
        /// </summary>
        CanPause = 1 << 5
    }
}
